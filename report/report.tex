\documentclass[a4paper,draft]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{roboto}
\usepackage{mathptmx}
\usepackage{tgtermes}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}

\usepackage{mathtools}
\usepackage{amsthm}
\usepackage{thmtools}
\declaretheorem{theorem}
\declaretheorem{lemma}
\declaretheorem{corollary}
\declaretheorem[style=definition,qed=$\blacktriangle$]{example}
\declaretheorem[style=definition,qed=$\blacktriangle$]{definition}
\numberwithin{equation}{section}

\usepackage{enumitem}
\setlist[enumerate,1]{label=\alph*)}
\newlist{prfcases}{enumerate}{1}
\setlist[prfcases,1]{label={\it Case \arabic*.},align=left,leftmargin=\parindent,itemindent=*}

\newenvironment{isabelle}{\list{}{}\item\relax}{\endlist}
\newcommand{\iindent}{\-\hspace{1em}}

\usepackage{algorithm}
\usepackage[final]{listings}
\lstset{numbers=left,firstnumber=1,stepnumber=5,numberfirstline,
	basicstyle=\ttfamily\small,keywordstyle=\ttfamily\small\itshape,columns=flexible}

\usepackage{tikz}
\usetikzlibrary{shapes.geometric,matrix,decorations.pathreplacing}
\tikzset{itermtree/.style={level distance=6mm,sibling distance=10mm,%
	edge from parent/.style={draw,solid},every node/.style={solid}}}
\tikzset{pure/.style={draw,rectangle,inner sep=4pt,minimum size=5mm}}
\tikzset{term/.style={draw,circle,inner sep=1pt,minimum size=5mm}}
\tikzset{ap/.style={fill,diamond,inner sep=0pt,minimum size=6pt}}
\tikzset{subtrm/.style={draw,isosceles triangle,isosceles triangle apex angle=55,%
	shape border rotate=90,minimum height=10mm,anchor=north,child anchor=north}}
\tikzset{subtrmf/.style={subtrm,level distance=10mm,sibling distance=16.67mm}}
\tikzset{subtrmn/.style={subtrm,level distance=4mm,sibling distance=6.67mm}}
\tikzset{abbrv/.style={dashed}}

\usepackage[english]{babel}
\hyphenation{Isa-belle}

\usepackage[
	style=numeric,
%	sorting=none,
	doi=false,
	urldate=long,
]{biblatex}
\addbibresource{bibliography.bib}

\usepackage[hidelinks]{hyperref}


\newcommand{\ldb}{\llbracket}
\newcommand{\rdb}{\rrbracket}
\newcommand{\todo}{\fbox{To do.}}

\newcommand{\oftype}{\mathrel{::}}
\newcommand{\funT}{\Rightarrow}
\newcommand{\abs}[2]{\lambda #1.\>#2}
\newcommand{\Imp}{\Longrightarrow}
\newcommand{\imp}{\longrightarrow}
\newcommand{\Iff}{\Longleftrightarrow}
\newcommand{\All}[2]{\bigwedge #1.\>#2}
\newcommand{\all}[2]{\forall #1.\>#2}
\newcommand{\tvar}[1]{{'\!\textit{#1}}}
\newcommand{\svar}[1]{\textit{?#1}}
\newcommand{\set}[2]{\{#1\mid #2\}}

\DeclareMathOperator{\pure}{\mathit{pure}}
\newcommand{\ap}{\diamond}
\DeclareMathOperator{\sterm}{\mathsf{term}}
\DeclareMathOperator{\spure}{\mathsf{pure}}
\DeclareMathOperator{\sivar}{\mathsf{var}}
\newcommand{\siabs}[2]{\mathsf{abs}\;#1.\>#2}
\newcommand{\sap}{\mathbin{\mathsf{`ap`}}}
\newcommand{\sapp}{\>}
\newcommand{\sabs}[2]{{\boldsymbol\lambda} #1.\>#2}
\newcommand{\tabs}[2]{{\boldsymbol\lambda}^\ast #1.\>#2}
\newcommand{\termeq}{=_{\alpha\beta\eta}}
\newcommand{\unlift}[1]{\left\downarrow #1\right.}
\DeclareMathOperator{\vars}{var}
\newcommand{\varseq}{\overrightarrow{\vars}}
\DeclareMathOperator{\abseq}{abs}


\title{Applicative Functors in Isabelle/HOL}
\author{Joshua Schneider}

\begin{document}

\begin{titlepage}\sf\large\raggedleft
\makeatletter
{\huge\bfseries\@title} \\
\vspace{7mm}
{\Large\@author} \\
\vspace{2cm}
Bachelor Thesis \\
(11-947-173) \\
\vspace{7mm}
\@date
\makeatother

\vspace{\fill}
Advisors: \\
Prof.\ Dr.\ David Basin \\
Dr.\ Andreas Lochbihler \\
\vspace{1cm}
Department of Computer Science, ETH ZÃ¼rich
\end{titlepage}

\section*{Abstract}

Applicative functors can be found in different contexts.
In functional programming, they abstract the addition of effects to types.
But also rather mathematical constructs like sets and infinite containers
are examples.
The key property of applicative functors is that they lift functions
to effectful computations.

We present a proof method based on applicative lifting, implemented for the
Isabelle/HOL proof assistant.
Hinze showed that properties of functions are often preserved when lifted.
While functors are represented naturally in the types of HOL, it is not
directly possible to reason based on this insight.
We propose an algorithm which computes a certain normal form of applicative
expressions, together with a checked proof of equivalence.
We explain formally how this normal form solves lifted equations.
For further flexibility, we take some ideas from combinatory logic:
Variables can be eliminated from applicative expressions by means of abstraction
algorithms.
This second approach takes the nuances of the particular functors into
consideration.
Together, we provide the development as a ready-to-use package for Isabelle.
We demonstrate it on algebraic structures lifted to streams and cotrees.


\pagebreak
\tableofcontents
\pagebreak
\input{introduction}
\input{design}
\input{normal_form}
\input{combinators}
\input{examples}
\input{conclusion}
\pagebreak
\printbibliography

\end{document}
