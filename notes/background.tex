\section{Background}\label{sec:background}

\subsection{Proving with Isabelle}\label{subsec:isabelle}

Isabelle was originally designed as a framework for interactive theorem
proving, without being restricted to a specific logical system~\cite{paulson90}.
However, one chooses a particular \emph{object-logic} in order to construct a
theory and prove theorems.
In this paper, we focus on the Isabelle/HOL object-logic~\cite{npw02}.
It implements the higher-order logic which was used in the HOL~system~
\cite{gordon93}, another proving environment.
Isabelle/HOL (or HOL from here~on) is arguably the most popular object-logic
of Isabelle, as it comes with an extensive library of readily formalized
mathematics.
It also supports modelling of functional programs by means of datatypes and
recursive functions, making it suitable for verification tasks.
We will further discuss the choice of HOL for the extension presented here in
Section \todo.

The basis of HOL is a slightly extended variant of simply-typed lambda calculus.
Therefore, every object (and every term representing such an object) has a
certain type attached to it.
We use lower-case greek letters $\alpha$, $\beta$, $\gamma$ as meta-variables
for types.
The language of types consists of base types, type variables, and compound
types.
Base types are represented by their name and include fundamental types like
the booleans $\mathit{bool}$ and the natural numbers $\mathit{nat}$.
Type variables stand for an arbitrary types.
In Isabelle syntax, they are distinguished by a prefixed `$'$', e.g.
$\tvar{a}$, $\tvar{b}$, $\tvar{c}$.
The polymorphism in HOL is quite restricted, though, because higher-ranked
types cannot be expressed:
There is no explicit quantifier on the type level.
This rules out functions which take a polymorphic function as an argument and
apply it to values of different types.
Compound types are built up of a type constructor and a list of types.
The type constructor determines the number of argument types.
For example, the unary type constructor $\mathit{set}$ denotes sets with
elements of a certain type.
The argument is written on the left as in $\mathit{nat\,set}$, the type of
sets of natural numbers.
Multiple types are written in parentheses: $(\alpha, \beta) \mathit{fun}$.
$\mathit{fun}$ is the special type constructor for (total) functions from
$\alpha$ to $\beta$.
More commonly, the infix operator $\funT$ is used.
It is right-associative, i.e. $\alpha \funT \beta \funT \gamma$ is notation for
$(\alpha, (\beta, \gamma) \mathit{fun}) \mathit{fun}$.
Note that type constructors are different from types and must always be
concrete.
In particular, it is not possible to use a variable in place of a type
constructor!

Terms follow the standard rules of lambda calculus.
Atomic terms are constants and variables.
Application of a function $f$ to an argument $x$ is written $f\,x$.
Functions with multiple arguments are commonly curried in HOL;
we can drop parentheses accordingly : $f\,x\,y$ is the same as $(f\,x)\,y$.
Abstraction of a term $t$ over the variable $x$ is written $\abs{x}{t}$.
Terms must be well-typed, of course.
The types of variables and polymorphic constants can usually be omitted, since
they are inferred automatically.
Explicit type constraints are denoted by $t \oftype \alpha$ and may occur
anywhere in a term.
While all terms are represented internally roughly as shown above, Isabelle
comes with extensible notation support.

\begin{example}\label{exmp:hol-terms}
We already introduced the type $\mathit{nat}$.
Number literals can be used directly.
Common arithmetic operators are available, like%
\footnote{These functions actually have a more generic type (they are
overloaded). We will look at this later on.}
$\mathit{plus} \oftype \mathit{nat} \funT \mathit{nat} \funT \mathit{nat}$.
We can also use infix operators:
\[ \abs{(x \oftype \mathit{nat})\,y}{1 + x * y} \]
is a function which multiplies two natural numbers and adds one to the result.
Another important type family are sets.
They can be specified as finite collections $\{\}$, $\{a, b, c\}$ etc., and
by using set comprehension:
Let $P$ be a predicate $\alpha \funT \mathit{bool}$.
Then $\{x.\; P x\}$ is the set of those values $x \oftype \alpha$ such that
$P x$ is true, and $\set{f x}{x.\; P x}$ is the image of that set under $f$.

Logical formulas are centered around truth values.
Thus, the usual connectives like conjunction $\land$ and implication $\imp$
operate on type $\mathit{bool}$.
Quantifiers work just as expected: The term
\[ \all{(x \oftype \mathit{nat})\,y}{x + y = y + x} \]
states that addition of natural numbers is commutative.
Note that $=$ is just another operator of polymorphic type
$\tvar{a} \funT \tvar{a} \funT \mathit{bool}$.
Internally, quantifiers are represented as constants applied to lambda
abstractions, which handle the variable binding.
\end{example}

In order to achieve the goal of supporting different object-logics,
Isabelle contains an immediate layer, the meta-logic Pure.
It is an ``intuitionistic fragment of higher-order logic''~\cite[27]{isar-ref}.
In Pure itself there is only the type $\mathit{prop}$ of propositions.
A term of this type combined with a proof relative to some context forms a
\emph{theorem}.
For now, the context is an abstract entity which may contain local hypotheses.
Assumptions can also be recorded explicitly in a proposition, using
meta-implication $\Imp$.
Note that this is technically different from HOL's implication $\imp$,
though there are theorems which allow conversion between the two.
The meta-quantifier $\bigwedge$ denotes universal quantification (with a
similar relationship to $\forall$); it is used to restrict the scope of
variables in assumptions.
Meta-equality $\equiv$ is the third main operator of Pure.
The generic rewriting and simplification tools work with such equations.
Again, conversion with $=$ is possible.
Object-logics embed their own notion of a proposition into Pure via
a truth judgement.
In HOL, this is the constant $\mathit{Trueprop} \oftype \mathit{bool \funT prop}$,
which turns an object-level formula into a proposition stating that said
formula is indeed true.
It is usually left implicit.
See \cite[Chapter~2]{implementation-ref} for further details about Pure.

Pure has two main uses within the Isabelle framework: representation and
manipulation of deduction rules, and goal states.
For the former, consider the traditional introduction rule for conjunction,
\[ \frac{\Gamma_1 \vdash P \qquad \Gamma_2 \vdash Q}{\Gamma_1 \cup \Gamma_2 \vdash P \land Q}, \]
which we want to turn into a theorem.
Deduction in Isabelle handles the contexts $\Gamma_i$ automatically, and
therefore do not have to be stated in the corresponding proposition.
The dependency of the conclusion $P \land Q$ on the hypotheses $P$ and $Q$
translates to repeated meta-implication.
This gives us the proposition
\[ \All{P Q}{P \Imp Q \Imp P \land Q} \]
(the $\mathit{Trueprop}$ markers have been omitted, and $P$, $Q$ range over
$\mathit{bool}$).
There is one quirk, however.
The outermost meta-quantified variables (and all type variables) % FIXME
are turned into schematic variables, which are free variables distinguished by
the prefix $\svar{}$.
Thus, the introduction rule as it is supplied by HOL appears as
\[ \mathtt{conjI}:\quad \svar{P} \Imp \svar{Q} \Imp \svar{P} \land \svar{Q}. \]
Schematic (type) variables are eligible for instantiation during
\emph{resolution}, which is Isabelle's primary tool for proof construction.
Resolution combines two rules (theorems), identifying an assumption of the
second with the conclusion of the first by higher-order unification.
Additionally, the first rule is brought into the context of that assumption.

A goal state is a theorem that represents a partially completed proof of some
proposition, the goal.
While the proof is incomplete, the remaining subgoals are tracked as
assumptions.
Proof steps transform the goal state.
The proof is finished once only the goal remains.

% TODO ML

In contemporary use of Isabelle, user input to the system is expressed in
the Isar language~\cite{wenzel99,wenzel02,isar-ref}.
It aims to encode proofs in a way that is formal, i.e. has precise semantics,
but still resembles informal patterns of reasoning.
The basic organization unit in Isar is a \emph{theory}.
The body of a theory consists of a sequence of commands, which consecutively
augment the logical context by declarations of various kinds.
Other theories may be imported in the beginning, leading to a acyclic graph
of theory dependencies.
Commands constitute the so-called outer syntax of Isar.
Terms and types occuring within them are parsed separately, according to the
inner syntax.
They are usually embedded in quotes `\texttt{"}\dots\texttt{"}' to disambiguate
them.
In certain cases, a command may put the theory state into proof mode.
% TODO goal, subgoal, nesting
After a proof is finished, the associated goal becomes a \emph{fact}.
% TODO facts by assumption

Some commonly used specifications are:
\begin{itemize}
\item The \textbf{definition} command introduces new constants by means of
	defining equations.
\item \todo{} \textbf{datatype}, \textbf{primrec}
\item Facts can be given names for further use in proofs.
	The canonical command for this is \textbf{lemma} and its variants
	\textbf{theorem} and \textbf{corollary}.
\item \todo{} \textbf{locale}?
\end{itemize}

Finally, there two syntactical categories which are repeatedly used in commands:
\emph{Proof methods} denote (possibly parameterized) operations on the goal state.
\emph{Attributes} invoke further processing steps on facts, either transforming
them or causing additional declarations.

% TODO
% - Isar example
