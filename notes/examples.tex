\section{Usage Examples}\label{sec:examples}

\subsection{User Interface}\label{subsec:detail-example}

\begin{figure}
\textbf{lemma} set\_plus\_assoc: $(X \oplus Y) \oplus Z = X \oplus (Y \oplus Z)$ \\
\textbf{proof} \\
\iindent \textbf{show} $X \oplus Y \oplus Z \subseteq X \oplus (Y \oplus Z)$ \textbf{proof} \\
\iindent\iindent \textbf{fix} $a$ \textbf{assume} $a \in X \oplus Y \oplus Z$ \\
\iindent\iindent \textbf{then obtain} $x$ $y$ $z$ \\
\iindent\iindent\iindent \textbf{where} elems: $x \in X$\hspace{1ex}$y \in Y$\hspace{1ex}$z \in Z$ \\
\iindent\iindent\iindent \textbf{and} sum: $a = x + y + z$ \\
\iindent\iindent\iindent \textbf{unfolding} set\_plus\_def ap\_set\_def \textbf{by} blast \\
\iindent\iindent \textbf{from} sum \textbf{have} $a = x + (y + z)$ \textbf{using} add.assoc \textbf{by} simp \\
\iindent\iindent \textbf{with} elems \textbf{show} $a \in X \oplus (Y \oplus Z)$ \\
\iindent\iindent\iindent \textbf{unfolding} set\_plus\_def ap\_set\_def \textbf{by} blast \\
\iindent \textbf{qed} \\
\textbf{next} \\
\iindent \textbf{show} $X \oplus (Y \oplus Z) \subseteq X \oplus Y \oplus Z$ \textbf{proof} \\
\iindent\iindent \emph{symmetric proof omitted \dots} \\
\iindent \textbf{qed} \\
\textbf{qed}

\caption{A semi-manual proof of the associative property of addition, lifted to sets.}
\label{fig:set-assoc-manual}
\end{figure}

This section demonstrates the user interface of our package by revisiting
Example~\ref{exmp:set-intro}.
We assume that $\oplus$ and $\ap$ for sets have been defined according to
equations \eqref{eq:set-plus} and~\eqref{eq:set-ap}, and ``set\_plus\_def'' and
``ap\_set\_def'' refer to these equations.
It is possible to prove the associative property with the standard facilities
of Isabelle/HOL, of course.
Figure~\ref{fig:set-assoc-manual} shows a canonical Isar proof.
Its structure follows natural reasoning about sets:
We prove set equality by showing mutual inclusion in both directions, each of
which is proven by the corresponding implication.
The operators in the term $a \in X \oplus Y \oplus Z$ are unfolded to obtain
nested set comprehensions.
The fully automatic proof method \emph{blast} is fortunately able to deduce
the relation to elements of the individual sets $X$, $Y$, $Z$.
Also note how the fact ``add.assoc'' is used in the middle---it states the base
equation.

The proof scheme can be adjusted for other properties.
It is, however, suitable only for the set idiom.
Inductive datatypes would likely need induction (or case splits for
non-recursive types), coinductive datatypes use coinduction, and so on.

Now we want to automate the full proof with our package.
First, it needs to be informed about the set idiom.
We provide a command to declare applicative functors:
\begin{isabelle}
	\textbf{applicative} set (C)
	\textbf{for} \\
	\iindent pure: $\abs{x}{\{x\}}$ \\
	\iindent ap: $\ap_\mathit{set}$ \\
	\textbf{unfolding} ap\_set\_def \textbf{by} fast+
\end{isabelle}
Its general syntax is
\begin{isabelle}
	\textbf{applicative} \textit{name} (\textit{combinator}, \dots) \\
	\textbf{for} \\
	\iindent pure: $\pure_f$\\
	\iindent ap: $\ap_f$ \\
	\textit{proof}
\end{isabelle}
The idiom will be made available under the \textit{name}.
It can be used to refer to the idiom manually in proofs.
The name is followed by an optional list of a subset of the symbols C, K, and W.
These declare which combinators are lifted, as explained in
Section~\ref{sec:combinators}.
The set idiom only lifts the $\mathbf{C}$ combinator.
The functions $\pure$ and $\ap$ imply the type scheme, see also
Section~\ref{subsec:proof-strategy}.
Finally, the idiom laws need to be proven.
The system presents the user with corresponding goals, which are solved by the
proof.
For sets, the goals are
\begin{align*}
1.\; & \All{x}{ \{\abs{x}{x}\} \ap x = x } \\
2.\; & \All{g f x}{ \{\abs{g f x}{g (f x)}\} \ap g \ap f \ap x = g \ap (f \ap x) } \\
3.\; & \All{f x}{ \{f\} \ap \{x\} = \{f x\} } \\
4.\; & \All{f x}{ f \ap \{x\} = \{\abs{f}{f x}\} \ap f } \\
5.\; & \All{f x y}{ \{\abs{f x y}{f y x}\} \ap f \ap x \ap y = f \ap y \ap x }
\end{align*}
In this example, the proof obligations are easily discharged by unfolding and
the automatic \emph{fast} prover.
After the command has been issued, the functor can be used in subsequent
commands.
Its data is stored in the theory context and thus can be imported along other
theory content.
This allows the construction of a reusable idiom library.

Next, the definition of $\oplus$ needs to be registered.
Otherwise, the proof method is not able to interpret a term like $X \oplus Y$ as
a composite idiomatic expression.
Lifted constants can be registered with the attribute \emph{applicative\_unfold},
which can be applied to facts $\mathit{lhs} = \mathit{rhs}$, where $\mathit{rhs}$
is an idiomatic expression.
The equation must be suitable for rewriting.

Finally, we are able to compress the proof to a single invocation of the new
proof method \emph{applicative\_lifting}.
The base equation is provided as a fact and is used automatically by the
supporting Isar framework:
\begin{isabelle}
\textbf{lemma} set\_plus\_assoc: $(X \oplus Y) \oplus Z = X \oplus (Y \oplus Z)$ \\
\textbf{using} add.assoc \textbf{by} applicative\_lifting
\end{isabelle}
The proof method can also be used when the variables in the lifted equation
have been instantiated with other terms.
