\section{Conclusion}\label{sec:conclusion}

\subsection{Related Work}\label{subsec:related-work}

There already exist libraries for Isabelle/HOL which perform certain kinds of
lifting.
In this section, we want to highlight two of them and discuss how they compare
to our solution.
The first package~\cite{huffman05} implements a ``transfer principle''
specifically designed for nonstandard analysis (NSA).
It focuses on a fixed target type constructor, $\alpha\,\mathit{star}$, which is
defined as a quotient type.
A quotient type is created from an existing type and an equivalence relation
on it; its elements are isomorphic to the equivalence classes.
Certain instances of $\alpha\,\mathit{star}$ form the nonstandard number types.
For instance, the hypernatural numbers are elements of $\mathit{nat}\,\mathit{star}$.
Arithmetic operators and their properties have to be lifted in order to develop
their theory, which is automated by the transfer tactic.
This goal is indeed very similar to ours, but just focused on one application.
Interestingly, the author of the NSA transfer package made use of the applicative
structure of $\alpha\,\mathit{star}$ to define lifted operators, and also predicates.
The latter is something the package presented in this report does not support.
We will briefly discuss it as a potential extension in the next section.

The automated lifting of properties is not generic over idioms, though.
This makes it possible to state all required rules directly as polymorphic
HOL theorems.
The tactic takes some lifted proposition, tries to find the base form by
deleting certain constants (compare this to our unfolding approach), and then
shows logical equivalence of the two by backchaining with suitable transfer
rules.
(We only provide implication from the base equation.)
There is only little control by the ML implementation, the process is mainly
guided by resolution with rule patterns.
Note that all parts of the input proposition go through the same process,
including logical operators.
This is a good place to mention that $\alpha\,\mathit{star}$ is based
on the function type $\mathit{nat} \funT \alpha$.
Therefore, all combinators can be lifted; variables can be handled by
resolution, because their order or duplication do not matter; all logical
operators are preserved by lifting (the lifted type can be thought of
as a collection of paramterized copies of the base formula).

We observe that the NSA transfer package is a lot more general than ours with
respect to lifted propositions, but is restricted to one particular idiom.
Many of the additional logical operators can only be lifted because of its
special properties.

The other package collection we want to discuss is related to quotient types as
well.
Recall that these are based on an underlying type, the representation.
The \emph{Lifting} and \emph{Transfer} packages~\cite{huffman13} provide a
modular infrastructure for transferring results from the representation level
to the new type.
\emph{Transfer} could be considered as a generalization of the NSA transfer tactic.
Instead of using rather free form transfer rules, it adheres to the concept of
relational parametricity.
Its own rules state how two different functions (or type instances of the same
function) are related, given relations of their arguments.
The body of known rules is used to search for equivalent or stronger propositions
of the input, with the intention that the latter is more easily proved.
The goal of \emph{Lifting} is to automate the specification of constants lifted
to quotient types.
Because this kind of lifting preserves properties by construction, they should be
carried over as well.
Therefore, the package uses transfer to relate the new constant with its
representation.

If we just have an applicative functor without additional properties, generic
transfer seems to be of little use.
\todo


\subsection{Summary and Future Extensions}\label{subsec:summary-future}

We have successfully implemented Hinze's applicative lifting as a proof method
for Isabelle/HOL.
\todo

The choice of a shallow embedding lead to a rather compact implementation,
next to the registration infrastructure, which is necessary either way.
On the other hand, the highly polymorphic situation needs constant care for
type parameter instantations, which is tedious.

The current implementation is restricted to equations.
As we have seen above, certain idioms can lift quite a lot more.
One example is cancellation of $\plus$ lifted to streams or infinite tree,
which is required to instantiate some of Isabelle's standard algebraic classes.
As a further motivation, it would be interesting to port the nonstandard
analysis to a generic applicative package.
\todo
