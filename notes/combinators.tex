\section{Lifting with Combinators}\label{sec:combinators}

\subsection{Motivation}\label{subsec:combinator-motivation}

The normalization approach to solving lifted equations works only if the
opaque terms on both sides coincide.
This is not true for all equations of interest.
Let's revisit the set version of addition of natural numbers, $\oplus$ from
Example~\ref{exmp:set-intro}.
This operator is also commutative, so it should be possible to prove
\[ X \oplus Y = Y \oplus X. \]
After unfolding and normalization, we get
\begin{equation}\label{eq:comb-intro1}
	\pure{(\abs{xy}{x + y})} \ap X \ap Y = \pure{(\abs{yx}{y + x})} \ap Y \ap X.
\end{equation}
Clearly, this can't be solved with a standard congruence rule, because we would
have to to prove that $X$ is equal to $Y$.
Since we are concerned with transferring properties from a base domain,
we don't want to assume anything about those opaque subterms.

Hinze showed that such equations can be solved if certain \emph{combinators}
can be lifted.
We have already used two combinators, $\mathbf{I}$ and $\mathbf{B}$.
Lifting their defining equations (see Table~\ref{tab:combinators}) gives us
the identity and composition laws, respectively.
Informally, combinators are functions which rearrange their arguments in a
specific manner.
If the lifted combinator performs the same rearrangement with arbitrary
functorial values, one can translate between the two layers.
In this case, we simply say that the combinator exists.
To continue with~\eqref{eq:comb-intro1}, we could attempt to change the order of
$Y$ and $X$ on the right-hand side.
Note that these appear as arguments to a pure function.
The $\mathbf{C}$ combinator, also known as `flip' in functional programming,
does what we want: $\mathbf{C}fxy = fyx$.
The lifted equation is
\begin{equation}\label{eq:flip-lifted}
	\pure \mathbf{C} \ap f \ap x \ap y = f \ap y \ap x,
\end{equation}
and it is indeed true for set idiom!
From this we get
\begin{equation}\label{eq:comb-intro2}
	\pure{(+)} \ap X \ap Y = \pure{(\operatorname{flip}(+))} \ap X \ap Y.
\end{equation}
The right-hand side is no longer the normal form of $Y \oplus X$, but still
a canonical form (which is why we distinguish these two).
But now the argument lists on both sides coincide.
We reduce to
\[ \abs{xy}{x + y} = \abs{xy}{y + x}, \]
which is extensionally equivalent to the base equation $x + y = y + x$.
The availability of equation~\eqref{eq:flip-lifted} is a quite powerful
condition, because it will allow us to permute opaque terms freely.
(The $\mathbf{C}$ does not exist for all applicative functors.
For example, the order of values in a state monad may be significant.)
If permutations exist such that both sides of an equation in canonical form
align regarding their opaque terms, reduction by congruence is possible again.
Furthermore, the effect of rewriting with $\mathbf{C}$ in one domain can be
reversed in the other.
This guarantees that the corresponding base equation is always applicable.

\begin{table}\centering
\begin{tabular}{cll}
Symbol & Reduction \\
\hline
$\mathbf{B}$ & $\mathbf{B} x y z = x (y z)$ \\
$\mathbf{I}$ & $\mathbf{I} x = x$ \\
\hline
$\mathbf{C}$ & $\mathbf{C} x y z = x z y$ \\
$\mathbf{K}$ & $\mathbf{K} x y = x$ \\
$\mathbf{W}$ & $\mathbf{W} x y = x y y$ \\
$\mathbf{S}$ & $\mathbf{S} x y z = x z (y z)$ \\
$\mathbf{H}$ & $\mathbf{H} x y z = x y (z y)$ \\
\end{tabular}
\caption{Useful combinators.}
\label{tab:combinators}
\end{table}

Combinators appeared originally in the context of logic~\cite{curry68}.
They were studied because it is possible to write logical formulas without
variables using only applications of suitable combinators, as opposed to the
usual lambda calculus.
Table~\ref{tab:combinators} lists all combinators which are used throughout
this text, together with their defining equations.
There are certain sets of combinators which are sufficient to express all
lambda terms, $\{\mathbf{S,K}\}$ being one of them.
In other sets, only a limited part of terms is representable.
Hinze's Lifting Lemma shows that all terms and thus all equations can be
lifted while preserving the variable structure if $\mathbf{S}$ and $\mathbf{K}$
exist.
He also notes that other combinator set are useful, because there are idioms
where more than $\{\mathbf{B,I}\}$, but not all combinators exist.
The original proof of the Lifting~Lemma~\cite[11--14]{hinze10} uses induction
on the structure of idiomatic terms; it is not entirely obvious how it can
be generalized to other combinators sets, as it depends on the availability
of $\mathbf{K}$ to lift tuple projections.
In this section we present an implementation of this generalized lifting,
whose underlying concept works with arbitrary combinators.
It depends on an abstraction algorithm and the structure of representable terms,
which are difficult to derive automatically.
Therefore we will restrict ourselves to certain sets (``bases'') with
hard-coded algorithms.

\subsection{Algorithm Outline}\label{subsec:general-algorithm}

The high-level method of proof is the same as with the one based on plain
normalization: Rewriting both sides of the equation, stripping equal terms by
congruence and finally resolving with the base equation.
The generalized approach differs in the rewriting step.
We will first discuss how one goes from the base equation to its lifted form.
In general, the base equation looks like this:
\[ \all{\vec x}{s[\vec x] = t[\vec x]}, \]
where $u[\vec x]$ means that variables $\vec x$ may occur freely in $u$.
By function extensionality, which is an axiom of HOL, this is true iff
\[ \abs{\vec x}{s[\vec x]} = \abs{\vec x}{t[\vec x]}. \]
Now we attempt to translate both terms to their combinator representation,
using those combinators which exists for the idiom we are working with.
The exact process depends on the combinator set, and may also fail if a term
is not representable with that set.
The details are discussed in the next section.
Let $s'$ and $t'$ be the translated terms.
Each can be viewed as an function application tree of some atomic terms.
We derive $\pure_f s' = \pure_f t'$ by simple substitution.
This is an equation of functions of type
\[ \tau_1 f \funT \cdots \funT \tau_n f \funT \sigma f, \]
with $\tau_i$ is the type of $x_i$, and $\sigma$ is the type of $s[\vec x]$.
It follows that
\[ \all{\vec y}{\pure s' \ap y_1 \ap \cdots \ap y_n =
	\pure t' \ap y_1 \cdots \ap y_n}. \]
The type of $y_i$ is $\tau_i f$.
The homomorphism law allows us to distribute $\pure$ over the applications
in $s'$ and $t'$, which makes it possible to unfold all lifted combinators.
For example, a subterm
\[ \pure \mathbf{S} \ap \pure f \ap x \ap y \]
gets rewritten to $\pure f \ap y \ap (x \ap y)$.
The result is the lifted equation (modulo splitting/joining of adjacent
$\pure$s), because the combinators capture the term--variable structure and
transfer it to the idiom.

However, a user should able to use the proof method without supplying the base
equation beforehand.
To do this, the procedure we have just described is essentially done backwards.
(The direction of logical implication remains the same, though.)
This may cause some issues if the proof goal cannot be represented using the
available combinators, but is an instantiation of a more general proposition
which can be proven.
An example is
\[ X \oplus (X \oplus Y) = (X \oplus X) \oplus Y. \]
We want this to be handled automatically, if possible.
In terms of above presentation, the algorithm has to determine the variables
$\vec y$ and find an assignment of all opaque terms to this variables, such
that the proof goes through.

\subsection{Combinator Bases}\label{subsec:combinator-bases}

\begin{table}\centering
\begin{tabular}{ll}
Base & Example idioms \\
\hline
$\mathbf{BI}$ & state, list \\
$\mathbf{BIC}$ & set \\
$\mathbf{BIK}$ & \\
$\mathbf{BIW}$ & either \\
$\mathbf{BCK}$ & \\
$\mathbf{BKW}$ & \\
$\mathbf{BICW}$ & maybe \\
$\mathbf{BCKW}$ & stream, $\alpha \to$ \\
\end{tabular}
\caption{Substructures of BCKW.}
\label{tab:combinator-bases}
\end{table}

\todo
