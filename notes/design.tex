\section{Requirements and Basic Design}\label{sec:design}

\subsection{Requirements}

Our primary goal is to implement an Isabelle/HOL proof method which reduces
lifted equations to their base form.
This proof method should be generic and work with arbitrary idioms.
The following is the minimal set of user actions we shall support:

\begin{enumerate}
\item Declare applicative functors to the theory context.
	Given a type constructor $f$, the functions $\pure_f$ and $\ap_f$, and
	proofs for the relevant functor laws, the functor is registered with the
	package such that it can be used in subsequent invocations of the
	proof method.
\item Prove lifted equations $a'[\vec{x}] = b'[\vec{x}]$, where $a'$ and $b'$
	are idiomatic expressions with free variables $\vec{x}$, using the base
	equation $\all{\vec{y}}{a[\vec{y}] = b[\vec{y}]}$.
	More precisely, if there is a subgoal stating the former, applying the
	proof methods transforms the goal state to the latter.
	The functor should be either detected automatically, or specified by
	the user.
\end{enumerate}

The first requirement ensures that our package is reusable, while the second
is the core functionality.
However, usability is also a concern: In the realm of interactive theorem
proving, it is not sufficient to just verify formal objects---we are not
extending the logic, after all, but providing a shortcut for a certain
principle.
We must balance the clarity of the resulting proof document and the amount of
work that the user has to put into developing a proof.
The following features are possible extensions which may help in this regard:

\begin{enumerate}
\setcounter{enumi}{2}
\item\label{itm:feat-const}
	Declare lifted constants and other terms to the theory context.
	Generally speaking, if a term $t$ with free variables $v_i$ can be expressed
	as $\pure t' \ap v_1 \ap \cdots \ap v_n$ for some $t'$, then the
	corresponding equation can be registered.
	The lifting proof methods rewrites with these equations at the beginning,
	such that the base equation will refer to $t'$.
	This way, the user does not have to transform everything into idiomatic
	format first.
\item\label{itm:feat-flex}
	More flexibility regarding the logical structure of the input proposition.
	This includes bound variables (quantified by $\forall$ or $\bigwedge$),
	complex subgoals with premises, and cases where the conceptual variables
	of the lifted equation have been subsituted by some terms.
\item\label{itm:feat-tools}
	Related proof methods and attributes, for example for forward lifting
	of proven base equations.
\item\label{itm:feat-debug}
	Inspection and tracing output.
	This is particular useful if something does not work as expected.
\item\label{itm:feat-xprops}
	Extend the notion of lifting beyond equations.
	It is possible to define lifting for other logical operators.
	For example, the cancellation law $a + b = a + c \longrightarrow b = c$
	consists of two equations, joined by implication.
	We can interpret it in different domains, e.g., for integers and for
	streams of integers with lifted $+$.
	In this example, the law is true for both interpretations.
	We are not able to handle such propositions with just a method for
	equations, though.
	% TODO example may fit better somewhere else?
\end{enumerate}

The current version at the time writing supports \ref{itm:feat-const} and
\ref{itm:feat-flex}, as well as \ref{itm:feat-tools} and \ref{itm:feat-debug}
to some extent.
\todo\ \ref{itm:feat-xprops} not discussed in detail, but see final section. % TODO
In the remainder of this section, we will explain the design decisions we
have made in order to fulfill the requirements.
Furthermore, the registration infrastructure and the basic proof approach are
explained.


\subsection{Choice of Embedding}\label{subsec:embedding}

In Isabelle, it is not possible to construct an abstract framework for
applicative functors in such a way that it is inhabited by all instances. % FIXME what
We already referred to the fact that type constructors are fixed.
Another issue is the lack of polymorphism in the inner logic:
We cannot have, say, a schematic variable \textit{?pure} and use it with
different types within the same proposition or proof.
One solution is to define a custom logic, including a term language, axioms
and meta theorems, and formalize it using the available specification tools.
This is a \emph{deep embedding} of the logic~\cite{wildmoser04}.
Then it would be possible to derive the Normal Form Lemma as a regular
inference rule, for example. % FIXME ref to NFL -- do we know it here already?
However, we want to prove propositions about arbitrary HOL objects, not just
their encodings in the embedded logic.
Some machinery, which performs the encoding and transfers results, is necessary.
\begin{itemize}
\item finite number of types involved per term $\implies$ could use sum types
\item number of types in sum is linear in size of terms
\item would introduce a large number of projections/abstractions
\end{itemize}
\todo

A different approach, which is the one we will take, is a \emph{shallow embedding}.
The ``formul\ae'' (here, idiomatic terms) are expressed directly in HOL.
Due to aforementioned restrictions, meta-theorectical results must be provided
in specialized form for each case.
We make use of the powerful ML interface of Isabelle to program the proof
construction.
The correctness of the proofs is still verified by the system, of course.
On the other hand, the correctness of the construction algorithm has to be
asserted externally.


% TODO reorganize below

\subsection{User Interface}\label{subsec:interface}

Since Isabelle's core logic does not allow parameterization of type constructors,
we need a custom mechanism for registering applicative functors with the
system.
In order to apply the proof method, the user must provide beforehand
\begin{enumerate}
	\item corresponding $\pure$ and $\ap$ instances, and
	\item a proof of the applicative functor laws, optionally with extended
	properties.
\end{enumerate}
Lifted constants may be registered with an attribute, which can be applied to
facts $\mathit{lhs} = \mathit{rhs}$, where $\mathit{rhs}$ is an idiomatic
expression.
These must be suitable for rewriting.

The complete set of subgoal forms to support has not been determined yet.
\todo{}
As a minimal requirement, after unfolding lifted constants, HOL equations of
idiomatic expressions shall be handled.
Only the outermost functor $f$ is considered per invocation.
The conceptual variables of the lifted expressions may be instantiated with
arbitrary terms.
However, the method actually proves the fully universally quantified form---%
for every subterm not matching $\pure_f{\_}$ or $\_ \ap_f \_$, a new, locally
quantified variable is introduced.
We call these subterms \emph{opaque}.
The method attempts to transform the first subgoal to the base form of the
equation, in other words, its identity functor interpretation.
Variable names shall be preserved, if possible.
Finally, it is desirable to have some kind of debugging facility for tracing
intermediate steps.
This may be especially useful if the proof fails because additional laws are
required.

\begin{example}\label{exmp:set-usage}
Continuing with the set idiom from Example~\ref{exmp:set-intro}, assume that
the user wants to prove an instantiation of the associativity law for $\oplus$
as part of a larger proof.
$\mathit{set}$ and $\oplus$ have been declared to the enclosing theory.
The current Isabelle goal state is
\[ 1. \quad (X \oplus Y) \oplus f Z = X \oplus (Y \oplus f Z). \]
The variables $X$, $Y$ and $Z$ have been fixed in the proof context, and $f$ is
some constant, all of appropriate type.
This illustrates how we allow a larger variety of propositions, making it
easier to apply the method without too much preparation.
After applying the proof method, the new proof obligation reads
\[ 1. \quad \All{x y u}{(x + y) + u = x + (y + u)}, \]
which is easily discharged.
The corresponding Isabelle/Isar fragment could be
\begin{isabelle}
	\textbf{fix} $X$ $Y$ $Z$ \\
	\dots \\
	\textbf{have} "$(X \oplus Y) \oplus f Z = X \oplus (Y \oplus f Z)$"
		\textbf{by} \textit{af\_lifting} \textit{algebra}
\end{isabelle}
\textit{af\_lifting} is our new proof method, and the standard \textit{algebra}
method completes the subproof.
% TODO check with final implementation
\end{example}

\subsection{Proof Strategy}\label{subsec:proof-strategy}

The proof method starts with testing the first subgoal for the expected
structure.
If the test succeeds, the applicative functor $f$ is known, such that the
relevant theorems can be accessed subsequently.
We then rewrite the subgoal using the declared rules for lifted constants.
Only those related to $f$ are used, the reason being that overeager, unwanted
unfolding may be difficult to reverse.
% TODO might not be true in the final version
The result of this preparation is a subgoal which is simple equation of two
idiomatic expressions.

The following step depends on which additional properties of $f$ have been
provided.
All approaches have in common that both expressions are replaced by others in
\emph{canonical form}:
\[ \pure{g} \ap s_1 \ap \cdots \ap s_m = \pure{h} \ap t_1 \ap \cdots \ap t_n, \]
If either $m \ne n$ or $t_i \ne s_i$ for some $i$ (as terms modulo
$\alpha\beta\eta$-conversion), the proof method fails.
Otherwise, we apply appropriate congruence rules until the subgoal is reduced
to $g = h$.
Since $g$ and $h$ are at least $n$-ary functions, we can further apply
extensionality, reaching the subgoal
\[ \All{x_1 \dots x_n}{g x_1 \cdots x_n = h x_1 \cdots x_n}. \]
This is the transformed proof state presented to the user.

Hinze's Normal Form Lemma~\cite[7]{hinze10} asserts the existence of a certain
normal form for idiomatic expressions where each variable occurs only once.
This normal form has the desired structure.
As it turns out, we can compute it for arbitrary terms.
This is convenient because opaque parts are handled implicitly.
However, the result might be too general and unprovable, so we will use the
normal form only if no other properties are available.
The details of the normalization algorithm are described in
Section~\ref{sec:normal-form}.
There we will also show that the transformed equation is exactly the generalized
base form of the original equation.

Hinze then explored under what circumstances a larger variety of equations can
be lifted.
He found that sufficient conditions can be expressed in terms of combinators
as known from combinatory logic.
We take this idea and adapt it our framework in Section~\ref{sec:combinators}.
In contrast to the normal form approach, we gain flexibility regarding the
opaque terms in the canonical form.
This means that the algorithm must determine the sequence $\vec t = \vec s$
of opaque terms prior to the transformations.
The set of available combinators further limits the admissible sequences.
Because this relationship cannot be generalized easily, we restrict ourselves
to certain combinator sets.
