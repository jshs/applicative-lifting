\section{Requirements and Basic Design}\label{sec:design}

\subsection{Requirements}

Our primary goal is to implement an Isabelle/HOL proof method which reduces
lifted equations to their base form.
This proof method should be generic and work with arbitrary idioms.
The following is the minimal set of user actions we shall support:

\begin{enumerate}
\item Declare applicative functors to the theory context.
	Given a type constructor $f$, the functions $\pure_f$ and $\ap_f$, and
	proofs for the relevant functor laws, the functor is registered with the
	package such that it can be used in subsequent invocations of the
	proof method.
\item Prove lifted equations $a'[\vec{x}] = b'[\vec{x}]$, where $a'$ and $b'$
	are idiomatic expressions with free variables $\vec{x}$, using the base
	equation $\all{\vec{y}}{a[\vec{y}] = b[\vec{y}]}$.
	More precisely, if there is a subgoal stating the former, applying the
	proof methods transforms the goal state to the latter.
	The functor should be either detected automatically, or specified by
	the user.
\end{enumerate}

The first requirement ensures that our package is reusable, while the second
is the core functionality.
However, usability is also a concern: In the realm of interactive theorem
proving, it is not sufficient to just verify formal objects---we are not
extending the logic, after all, but providing a shortcut for a certain
principle.
We must balance the clarity of the resulting proof document and the amount of
work that the user has to put into developing a proof.
The following features are possible extensions which may help in this regard:

\begin{enumerate}
\setcounter{enumi}{2}
\item\label{itm:feat-const}
	Declare lifted constants and other terms to the theory context.
	Generally speaking, if a term $t$ with free variables $v_i$ can be expressed
	as $\pure t' \ap v_1 \ap \cdots \ap v_n$ for some $t'$, then the
	corresponding equation can be registered.
	The lifting proof methods rewrites with these equations at the beginning,
	such that the base equation will refer to $t'$.
	This way, the user does not have to transform everything into idiomatic
	format first.
\item\label{itm:feat-flex}
	More flexibility regarding the logical structure of the input proposition.
	This includes bound variables (quantified by $\forall$ or $\bigwedge$),
	complex subgoals with premises, and cases where the conceptual variables
	of the lifted equation have been subsituted by some terms.
\item\label{itm:feat-tools}
	Related proof methods and attributes, for example for forward lifting
	of proven base equations.
\item\label{itm:feat-debug}
	Inspection and tracing output.
	This is particular useful if something does not work as expected.
\item\label{itm:feat-xprops}
	Extend the notion of lifting beyond equations.
	It is possible to define lifting for other logical operators.
	For example, the cancellation law $a + b = a + c \longrightarrow b = c$
	consists of two equations, joined by implication.
	We can interpret it in different domains, e.g., for integers and for
	streams of integers with element-wise addition.
	In this example, the law is true for both interpretations.
	We are not able to handle such propositions with just a method for
	equations, though.
	% TODO example may fit better somewhere else?
\end{enumerate}

The current version at the time writing supports \ref{itm:feat-const} and
\ref{itm:feat-flex}, as well as \ref{itm:feat-tools} and \ref{itm:feat-debug}
to some extent.
\todo\ \ref{itm:feat-xprops} not discussed in detail, but see final section. % TODO
In the remainder of this section, we will explain the design decisions we
have made in order to fulfill the requirements.
Furthermore, the registration infrastructure and the basic proof approach are
explained.


\subsection{Choice of Embedding}\label{subsec:embedding}

The package should support many different applicative functors.
We are interested in functors on the type level, where application is based on
the standard function space.
Therefore, each idiom comes with a type family which is indexed by a
distinguished type variable, and the related functions and laws are polymorphic
in this index.
This is the natural form of idioms in the HOL libraries; all examples in \todo\
are parametric datatypes.  % TODO ref
Regardless of the mechanism of proof construction, it needs a type constructor
as a parameter.
This concept is foreign to the type system of Pure and HOL---%
we already referred to the fact that type constructors are fixed.
Another issue is the lack of polymorphism in the inner logic:
We cannot have, say, a schematic variable \textit{?pure} and use it with
different types within the same proposition or proof.
From this we conclude that we cannot prove lifting inside the logic as a
inference rule that could be applied directly to equations.

One solution is to define a custom logic, including a term language, axioms
and meta theorems, and formalize it using the available specification tools.
In our case, the language is that of idiomatic expressions,%
\footnote{Base equations can be interpreted as expressions of the identity idiom.}
the axioms describe an equality judgment which is compatible with the
applicative functor laws, and lifting of equations is a theorem.
This is a \emph{deep embedding} of the logic~\cite{wildmoser04}.
With its tools for algebraic datatypes and recursive functions, reasoning about
such an embedding is quite manageable in HOL.
However, we want to prove propositions involving objects of HOL itself, not just
their encodings in the embedded language.
Some machinery, known as reflection, needs to perform the encoding and transfer
back results.
It must be implemented necessarily outside of the logic, but can be generic.
Chaieb and Nipkow have implemented a proof procedure using a deep embedding and
reflection in Isabelle~\cite{chaieb05}.
They point out that their approach also functions as a verification of the
proof procedure, is portable and has smaller proofs than those obtained by
automating inference rules.
Their reflection system does not support polymorphism to the extent we need,
though.

The package for nonfree datatypes~\cite{schropp13} is deeply embedded as well.
Its constructions must work with arbitrary types.
In the underlying framework, Schropp~\cite{schropp12} proposed the use of a
``pseudo-universe'', a sum type combining all these types.
The meta-theory of the package carries a type parameter which is instantiated
with a suitable pseudo-universe for every construction.
It may be possible to use the same approach for idiomatic expressions, since the
number of types occuring in an idiomatic expression is finite.
This number can be linear in the size of the expression, though, which bloats
the intermediate terms during reflection.
A bigger problem is the generic axiomatization of idioms.
For instance, the identity law would refer to a function of type $\alpha \funT \alpha$
for each type $\alpha$ in the pseudo-universe.
Thus, the universe needs to be closed under function types.
It is not clear to the author how this could be modelled.

A different approach, which is the one we will take, is a \emph{shallow embedding}.
The formulas (here, idiomatic terms) are expressed directly in the language of HOL.
Due to aforementioned restrictions, meta-theorectical results must be provided
in specialized form for each case.
We use the powerful ML interface of Isabelle to program the proof construction,
composing inferences according to the structure of the input equation.
The handling of polymorphism is simplified, as we have full control over
term and theorem instantiations.
The system still verifies the soundness of the synthesized proofs.
On the other hand, one has to assert externally that the construction algorithm
itself is correct, i.e., complete.
The main part of this report therefore justifies these algorithms.
% TODO untyped NF theory?


% TODO reorganize below

\subsection{User Interface}\label{subsec:interface}

Since Isabelle's core logic does not allow parameterization of type constructors,
we need a custom mechanism for registering applicative functors with the
system.
In order to apply the proof method, the user must provide beforehand
\begin{enumerate}
	\item corresponding $\pure$ and $\ap$ instances, and
	\item a proof of the applicative functor laws, optionally with extended
	properties.
\end{enumerate}
Lifted constants may be registered with an attribute, which can be applied to
facts $\mathit{lhs} = \mathit{rhs}$, where $\mathit{rhs}$ is an idiomatic
expression.
These must be suitable for rewriting.

The complete set of subgoal forms to support has not been determined yet.
\todo{}
As a minimal requirement, after unfolding lifted constants, HOL equations of
idiomatic expressions shall be handled.
Only the outermost functor $f$ is considered per invocation.
The conceptual variables of the lifted expressions may be instantiated with
arbitrary terms.
However, the method actually proves the fully universally quantified form---%
for every subterm not matching $\pure_f{\_}$ or $\_ \ap_f \_$, a new, locally
quantified variable is introduced.
We call these subterms \emph{opaque}.
The method attempts to transform the first subgoal to the base form of the
equation, in other words, its identity functor interpretation.
Variable names shall be preserved, if possible.
Finally, it is desirable to have some kind of debugging facility for tracing
intermediate steps.
This may be especially useful if the proof fails because additional laws are
required.

\begin{example}\label{exmp:set-usage}
Continuing with the set idiom from Example~\ref{exmp:set-intro}, assume that
the user wants to prove an instantiation of the associativity law for $\oplus$
as part of a larger proof.
$\mathit{set}$ and $\oplus$ have been declared to the enclosing theory.
The current Isabelle goal state is
\[ 1. \quad (X \oplus Y) \oplus f Z = X \oplus (Y \oplus f Z). \]
The variables $X$, $Y$ and $Z$ have been fixed in the proof context, and $f$ is
some constant, all of appropriate type.
This illustrates how we allow a larger variety of propositions, making it
easier to apply the method without too much preparation.
After applying the proof method, the new proof obligation reads
\[ 1. \quad \All{x y u}{(x + y) + u = x + (y + u)}, \]
which is easily discharged.
The corresponding Isabelle/Isar fragment could be
\begin{isabelle}
	\textbf{fix} $X$ $Y$ $Z$ \\
	\dots \\
	\textbf{have} "$(X \oplus Y) \oplus f Z = X \oplus (Y \oplus f Z)$"
		\textbf{by} \textit{af\_lifting} \textit{algebra}
\end{isabelle}
\textit{af\_lifting} is our new proof method, and the standard \textit{algebra}
method completes the subproof.
% TODO check with final implementation
\end{example}

\subsection{Proof Strategy}\label{subsec:proof-strategy}

The proof method starts with testing the first subgoal for the expected
structure.
If the test succeeds, the applicative functor $f$ is known, such that the
relevant theorems can be accessed subsequently.
We then rewrite the subgoal using the declared rules for lifted constants.
Only those related to $f$ are used, the reason being that overeager, unwanted
unfolding may be difficult to reverse.
% TODO might not be true in the final version
The result of this preparation is a subgoal which is simple equation of two
idiomatic expressions.

The following step depends on which additional properties of $f$ have been
provided.
All approaches have in common that both expressions are replaced by others in
\emph{canonical form}:
\[ \pure{g} \ap s_1 \ap \cdots \ap s_m = \pure{h} \ap t_1 \ap \cdots \ap t_n, \]
If either $m \ne n$ or $t_i \ne s_i$ for some $i$ (as terms modulo
$\alpha\beta\eta$-conversion), the proof method fails.
Otherwise, we apply appropriate congruence rules until the subgoal is reduced
to $g = h$.
Since $g$ and $h$ are at least $n$-ary functions, we can further apply
extensionality, reaching the subgoal
\[ \All{x_1 \dots x_n}{g x_1 \cdots x_n = h x_1 \cdots x_n}. \]
This is the transformed proof state presented to the user.

Hinze's Normal Form Lemma~\cite[7]{hinze10} asserts the existence of a certain
normal form for idiomatic expressions where each variable occurs only once.
This normal form has the desired structure.
As it turns out, we can compute it for arbitrary terms.
This is convenient because opaque parts are handled implicitly.
However, the result might be too general and unprovable, so we will use the
normal form only if no other properties are available.
The details of the normalization algorithm are described in
Section~\ref{sec:normal-form}.
There we will also show that the transformed equation is exactly the generalized
base form of the original equation.

Hinze then explored under what circumstances a larger variety of equations can
be lifted.
He found that sufficient conditions can be expressed in terms of combinators
as known from combinatory logic.
We take this idea and adapt it our framework in Section~\ref{sec:combinators}.
In contrast to the normal form approach, we gain flexibility regarding the
opaque terms in the canonical form.
This means that the algorithm must determine the sequence $\vec t = \vec s$
of opaque terms prior to the transformations.
The set of available combinators further limits the admissible sequences.
Because this relationship cannot be generalized easily, we restrict ourselves
to certain combinator sets.
